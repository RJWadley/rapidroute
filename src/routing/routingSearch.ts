/* eslint-disable no-restricted-syntax */
/* eslint-disable no-await-in-loop */
/* eslint-disable @typescript-eslint/no-unused-vars */

import { Location, Route } from "../data";
import { getAll, getPath } from "../data/getData";
import getRouteTime from "./getRouteTime";
import PriorityQueue from "./PriorityQueue";
import { throttle } from "./util";

const allLocations = getAll("locations");

interface Edge {
  route: Route;
  from: Location;
  to: Location;
  cost: number;
}

interface Result {
  path: Edge[];
  totalCost: number;
}

async function getEdges(fromLocation: Location): Promise<Edge[]> {
  const rawRoutes = fromLocation.routes
    ? await Promise.all(
        fromLocation.routes.map(async (routeId) => getPath("routes", routeId))
      )
    : [];

  // filter out null
  const routes = rawRoutes.flatMap((f) => (f ? [f] : []));

  // generate routes from location to each of routes locations
  const locations = await allLocations;
  const edges: Edge[] = routes.flatMap((route) => {
    return Object.keys(route.locations).flatMap((to) => {
      if (to === fromLocation.uniqueId) {
        return [];
      }
      return locations[to]
        ? {
            route,
            from: fromLocation,
            to: locations[to],
            cost: getRouteTime(fromLocation, locations[to], route.type),
          }
        : [];
    });
  });

  const walkingEdges: Edge[] = Object.keys(locations).map((key) => {
    const loc = locations[key];
    const edge: Route = {
      type: "walk",
      provider: "walk",
      name: `Walk from ${fromLocation.name} to ${loc.name}`,
      description: "",
      autoGenerated: true,
      locations: {
        [fromLocation.uniqueId]: "none",
        [loc.uniqueId]: "none",
      },
    };
    return {
      route: edge,
      from: fromLocation,
      to: loc,
      cost: getRouteTime(fromLocation, loc, "walk"),
    };
  });

  return [...edges, ...walkingEdges];
}

export default class Search {
  start: Location;

  end: Location;

  maxCost = Infinity;

  EXTRA_COST = 100;

  constructor(start: Location, end: Location) {
    this.start = start;
    this.end = end;
  }

  heuristic(edge: Edge, costSoFar: number): number {
    const costAfter = costSoFar + edge.cost;
    const walkTimeToEnd = getRouteTime(edge.to, this.end, "walk");
    const totalCost = costAfter + walkTimeToEnd;
    this.maxCost = Math.min(this.maxCost, totalCost);

    if (totalCost !== Infinity && totalCost > this.maxCost + this.EXTRA_COST) {
      return Infinity;
    }

    return 0;
  }

  async search(): Promise<Result> {
    const frontier = new PriorityQueue<Edge>();
    const cameFrom: Record<string, Edge> = {};
    const costSoFar: Record<string, number> = {};

    const startEdges = await getEdges(this.start);
    for (const edge of startEdges) {
      frontier.enqueue(edge, edge.cost);
      cameFrom[edge.to.uniqueId] = edge;
      costSoFar[edge.to.uniqueId] = edge.cost;
    }

    while (!frontier.isEmpty()) {
      await throttle();
      const current = frontier.dequeue();
      if (!current || current.to.uniqueId === this.end.uniqueId) {
        break;
      }
      const edges = await getEdges(current.to);
      for (const next of edges) {
        const newCost = costSoFar[current.to.uniqueId] + next.cost;
        if (
          !(next.to.uniqueId in costSoFar) ||
          newCost < costSoFar[next.to.uniqueId]
        ) {
          costSoFar[next.to.uniqueId] = newCost;
          const priority = newCost + this.heuristic(next, newCost);
          frontier.enqueue(next, priority);
          cameFrom[next.to.uniqueId] = next;
        }
      }
    }

    const path: Edge[] = [];
    let current = this.end;
    while (current.uniqueId !== this.start.uniqueId) {
      const edge = cameFrom[current.uniqueId];
      path.push(edge);
      current = edge.from;
    }
    path.reverse();

    return {
      path,
      totalCost: costSoFar[this.end.uniqueId],
    };
  }
}
