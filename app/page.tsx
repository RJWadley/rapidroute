import { styled } from "@linaria/react"
import {
	HydrationBoundary,
	QueryClient,
	dehydrate,
} from "@tanstack/react-query"
import AppGrid from "./AppGrid"
import MinecraftMap from "./components/Map/MapServer"
import { RoutingProvider } from "./components/RoutingContext"
import "./global.css"
import { getCompressedPlaces } from "./utils/compressedPlaces"
import { findClosestPlace } from "./utils/search"
import { data } from "app/data"
import { redirect } from "next/navigation"

export const metadata = {
	title: "Create Next App!!!",
	description: "Generated by create next app",
}

const baseURL = process.env.VERCEL_URL
	? `https://${process.env.VERCEL_URL}`
	: "http://localhost:3000"

export default async function MainPage({
	searchParams,
}: {
	searchParams: { [key: string]: string | string[] | undefined }
}) {
	const promises: Promise<unknown>[] = []
	const queryClient = new QueryClient()
	const compressedPlaces = getCompressedPlaces(await data)

	const params = new URLSearchParams()
	for (const [key, value] of Object.entries(searchParams)) {
		if (Array.isArray(value)) {
			for (const v of value) {
				params.append(key, v)
			}
		} else if (typeof value === "string") params.append(key, value)
	}

	const fromID = Array.isArray(searchParams.from)
		? searchParams.from[0]
		: searchParams.from
	const toID = Array.isArray(searchParams.to)
		? searchParams.to[0]
		: searchParams.to
	const fromPlace = findClosestPlace(fromID, compressedPlaces)
	const toPlace = findClosestPlace(toID, compressedPlaces)
	const name =
		toPlace?.type === "Coordinate" ? null : toPlace?.name || toPlace?.id || toID

	/**
	 * if we don't have a valid from or to, rewrite to the correct page
	 */
	if (fromID && !fromPlace) {
		params.delete("from")
		redirect(`/?${params.toString()}`)
	}
	if (toID && !toPlace) {
		params.delete("to")
		redirect(`/?${params.toString()}`)
	}

	if (!fromID) {
		// prefetch wiki article
		promises.push(
			queryClient.prefetchQuery({
				queryKey: ["wiki-article", name],
				queryFn: async () => {
					if (!name) throw new Error("no title")
					const content = await fetch(
						`${baseURL}/components/Wiki/getArticleContent/${name}`,
					)
					const result = await content.json()
					return result
				},
			}),
		)
	}

	// prefetch route
	// TODO - reenable prefetch
	// promises.push(
	// 	queryClient.prefetchQuery({
	// 		queryKey: ["find-path", fromID, toID],
	// 		queryFn: () => findPath(fromID, toID),
	// 	}),
	// )

	// prefetch search params
	promises.push(
		queryClient.prefetchQuery({
			queryKey: ["search-params"],
			queryFn: () => searchParams,
		}),
	)

	// wait for all promises to resolve - with a timeout to prevent page delay
	await Promise.race([
		Promise.allSettled(promises),
		new Promise((resolve) => setTimeout(resolve, 1000)),
	])

	return (
		<HydrationBoundary state={dehydrate(queryClient)}>
			<RoutingProvider>
				<Application>
					<MinecraftMap />
					<AppGrid places={await compressedPlaces} />
				</Application>
			</RoutingProvider>
		</HydrationBoundary>
	)
}

const Application = styled.div`
	width: 100dvw;
	height: 100dvh;
	overflow: clip;
	display: grid;
	grid-template-columns: 1fr 1fr 1fr;
	place-items: start stretch;
`
