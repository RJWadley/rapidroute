generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// A place, like a city, airport, or bus stop
model Place {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    name      String    @unique
    IATA      String?   @unique
    // some places, like MRT stations, have a short code
    placeCode String?
    type      PlaceType
    worldName WorldName

    coordinate_x Int?
    coordinate_z Int?
    routeFroms   RouteLeg[]   @relation(name: "fromPlace")
    routeTos     RouteLeg[]   @relation(name: "toPlace")
    routeSpokes  RouteSpoke[]
}

enum PlaceType {
    Airport
    City
    MrtStation
}

enum WorldName {
    New
    Old
    Space
}

// anybody that provides routes, like an airline or bus company
model Company {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    name         String  @unique
    numberPrefix String?
    color_dark   String?
    color_light  String?
    logo         String?

    route Route[]
}

// metadata about a particular route, like a flight or rail line
model Route {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // rail lines typically have names
    name   String?
    // whereas flights have numbers
    number String?
    type   RouteType

    // the metadata for this specific route. if not present, we use the company's
    color_dark  String?
    color_light String?
    logo        String?

    company     Company      @relation(fields: [companyId], references: [id], onDelete: Cascade)
    companyId   String
    connections RouteLeg[]
    routeSpoke  RouteSpoke[]

    // each company can only have one route with a given name
    @@unique([companyId, name])
    // each company can only have one route with a given number
    @@unique([companyId, number])
}

enum RouteType {
    PlaneFlight
    HelicopterFlight
    SeaplaneFlight
    MRT

    // Not Used in the DB, but still valid
    Walk
    SpawnWarp
}

// for linear routes, like a minecart track or a road
model RouteLeg {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    route   Route?  @relation(fields: [routeId], references: [id], onDelete: Cascade)
    routeId String?

    fromPlace   Place?  @relation(name: "fromPlace", fields: [fromPlaceId], references: [id], onDelete: Cascade)
    fromPlaceId String?
    fromGate    String?

    toPlace   Place?  @relation(name: "toPlace", fields: [toPlaceId], references: [id], onDelete: Cascade)
    toPlaceId String?
    toGate    String?
}

// for spoke style routes where every place is connected to every other place
model RouteSpoke {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    route      Route?  @relation(fields: [routeId], references: [id], onDelete: Cascade)
    routeId    String
    place      Place   @relation(fields: [placeId], references: [id], onDelete: Cascade)
    placeId    String
    placeeGate String?

    // each route can only spoke to a given place once
    @@unique([placeId, routeId])
}
