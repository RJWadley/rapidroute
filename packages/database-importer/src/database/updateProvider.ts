import { databaseTypeGuards, Provider } from "@rapidroute/database-utils"

import { database } from "./database"
import deepCompare from "./deepCompare"
import { isObject } from "./makeSafeForDatabase"

const isProvider = databaseTypeGuards.providers
const unusedKeys: Record<string, string[]> = {}

export function setProvider(
  providerId: string,
  provider: Provider | undefined | null
) {
  if (!database.providers) database.providers = {}

  // remove the providerId from the unusedKeys
  Object.entries(unusedKeys).forEach(([key, value]) => {
    unusedKeys[key] = value.filter(id => id !== providerId)
  })

  // Get the previous provider from the database
  const thisProvider = database.providers[providerId]
  const previousProvider: Provider | undefined = thisProvider
    ? {
        ...thisProvider,
        uniqueId: providerId,
      }
    : undefined

  // Validate the previous provider. If it's invalid, throw an error
  if (isObject(previousProvider)) previousProvider.uniqueId = providerId
  // check for any changes
  if (deepCompare(previousProvider, provider)) return

  if (
    previousProvider !== undefined &&
    previousProvider !== null &&
    !isProvider(previousProvider)
  ) {
    console.log(previousProvider)
    throw new Error(`Invalid provider: ${providerId}`)
  }

  // if the previous provider is not auto-generated, skip it
  if (previousProvider?.autoGenerated === false) {
    console.log("Skipping a non-auto-generated provider", providerId)
    return
  }
  // verify the provider is meant to come from this source
  if (
    previousProvider &&
    provider &&
    !previousProvider.autoGenerated &&
    previousProvider.autoGenerated !== provider.autoGenerated
  ) {
    console.log(
      "Source mismatch, skipping",
      providerId,
      previousProvider,
      provider
    )
    return
  }

  // Save the new provider to the database
  if (provider) database.providers[providerId] = provider
  else delete database.providers[providerId]

  console.log(
    provider
      ? `Successfully saved provider ${providerId}`
      : `Successfully deleted provider ${providerId}`
  )
}

/**
 * before making any changes to the database, get a list of all the keys
 * in the database so we can remove any that are no longer used after the update
 * @param source the source of the data, currently not used (but will be in the future)
 */
export function beforeProviderUpdate(source: string | true = true) {
  // get all the providers from the database where autoGenerated matches source
  const keys = Object.keys(database.providers || {}).filter(
    key => database.providers?.[key]?.autoGenerated === source
  )
  const sourceAsKey = typeof source === "string" ? source : "true"
  unusedKeys[sourceAsKey] = keys
}

/**
 * after making changes to the database, remove any locations that were unused or gone
 * @param source the source of the data, currently not used (but will be in the future)
 */
export function afterProviderUpdate(source: string | true = true) {
  const sourceAsKey = typeof source === "string" ? source : "true"
  const keysToRemove = unusedKeys[sourceAsKey]
  if (keysToRemove !== undefined) {
    keysToRemove.forEach(key => {
      setProvider(key, undefined)
    })
  }
}
