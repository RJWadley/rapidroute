import { databaseTypeGuards, Location } from "@rapidroute/database-types"
import { PathingPlace } from "@rapidroute/database-types/dist/src/pathfinding"
import { SearchIndexItem } from "@rapidroute/database-types/dist/src/searchIndex"

import { database } from "./database"
import deepCompare from "./deepCompare"

const isLocation = databaseTypeGuards.locations
const unusedKeys: Record<string, string[]> = {}

export function setLocation(
  locationId: string,
  location: Location | undefined | null
) {
  if (!database.locations) database.locations = {}
  if (!database.pathfinding) database.pathfinding = {}
  if (!database.searchIndex) database.searchIndex = {}

  // remove the locationId from the unusedKeys
  Object.entries(unusedKeys).forEach(([key, value]) => {
    unusedKeys[key] = value.filter(id => id !== locationId)
  })

  // Get the previous location from the database
  const previousLocation: Location | undefined = database.locations[locationId]
    ? {
        ...database.locations[locationId],
        uniqueId: locationId,
      }
    : undefined

  // check for any changes
  if (deepCompare(previousLocation, location)) {
    return
  }
  if (
    previousLocation !== undefined &&
    previousLocation !== null &&
    !isLocation(previousLocation)
  ) {
    console.log(previousLocation)
    throw new Error(`Invalid location: ${locationId}`)
  }

  // if the previous location is not auto-generated, skip it
  if (previousLocation?.autoGenerated === false) {
    console.log("Skipping a non-auto-generated location", locationId)
    return
  }
  // verify the location is meant to come from this source
  if (
    previousLocation &&
    location &&
    previousLocation?.autoGenerated !== true &&
    previousLocation?.autoGenerated !== location.autoGenerated
  ) {
    console.log(
      "Source mismatch, skipping",
      locationId,
      previousLocation,
      location
    )
    return
  }

  // Save the new location to the database
  if (location) database.locations[locationId] = location
  else delete database.locations[locationId]

  // update pathfinding index
  if (location) {
    const newValue: PathingPlace = {
      uniqueId: locationId,
      x: location.location?.x,
      z: location.location?.z,
      w: location.isSpawnWarp,
    }
    database.pathfinding[locationId] = {
      ...database.pathfinding[locationId],
      ...newValue,
    }
  } else {
    delete database.pathfinding[locationId]
  }

  // update search index
  if (location) {
    const newValue: SearchIndexItem = {
      uniqueId: locationId,
      d: `${location.shortName} - ${location.name}`,
      i: `${location.name} ${location.shortName} ${
        location.ownerPlayer instanceof Array
          ? location.ownerPlayer.join(" ")
          : location.ownerPlayer ?? ""
      } ${location.keywords ?? ""}`,
    }
    database.searchIndex[locationId] = newValue
  } else {
    delete database.searchIndex[locationId]
  }

  console.log(
    location
      ? `Successfully saved location ${locationId}`
      : `Successfully deleted location ${locationId}`
  )
}

/**
 * save a list of every location key in the database
 * @param source
 */
export function beforeLocationUpdate(source: string | true = true) {
  // get all the locations from the database where autoGenerated matches source
  const keys = Object.keys(database.locations || {}).filter(
    key => database.locations?.[key]?.autoGenerated === source
  )

  const sourceAsKey = typeof source === "string" ? source : "true"
  unusedKeys[sourceAsKey] = keys
}

export function afterLocationUpdate(source: string | true = true) {
  const sourceAsKey = typeof source === "string" ? source : "true"

  const keysToRemove = unusedKeys[sourceAsKey]
  if (keysToRemove !== undefined) {
    keysToRemove.forEach(key => setLocation(key, undefined))
  }
}
