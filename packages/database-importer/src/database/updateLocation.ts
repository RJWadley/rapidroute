import { databaseTypeGuards, Location } from "@rapidroute/database-types"
import { PathingPlace } from "@rapidroute/database-types/dist/src/pathfinding"
import { SearchIndexItem } from "@rapidroute/database-types/dist/src/searchIndex"

import database from "./database"
import deepCompare from "./deepCompare"
import makeSafeForDatabase, { isObject } from "./makeSafeForDatabase"
import throttledMap from "./throttledMap"

const isLocation = databaseTypeGuards.locations
const unusedKeys: Record<string, string[]> = {}

export async function setLocation(
  locationId: string,
  location: Location | undefined | null
) {
  // remove the locationId from the unusedKeys
  Object.entries(unusedKeys).forEach(([key, value]) => {
    unusedKeys[key] = value.filter(id => id !== locationId)
  })

  // Get the previous location from the database
  const snapshot = await database.ref(`locations/${locationId}`).get()
  const previousLocation: unknown = snapshot.val()

  // Validate the previous location. If it's invalid, throw an error
  if (isObject(previousLocation)) previousLocation.uniqueId = locationId
  // check for any changes
  if (deepCompare(previousLocation, location)) {
    console.log("No changes to route", locationId)
    return
  }
  if (
    previousLocation !== undefined &&
    previousLocation !== null &&
    !isLocation(previousLocation)
  ) {
    console.log(previousLocation)
    throw new Error(`Invalid location: ${locationId}`)
  }

  // if the previous route is not auto-generated, skip it
  if (previousLocation?.autoGenerated === false) {
    console.log("Skipping a non-auto-generated route", locationId)
    return
  }
  // verify the route is meant to come from this source
  if (
    previousLocation &&
    location &&
    previousLocation?.autoGenerated !== true &&
    previousLocation?.autoGenerated !== location.autoGenerated
  ) {
    console.log(
      "Source mismatch, skipping",
      locationId,
      previousLocation,
      location
    )
    return
  }

  // Save the new location to the database
  await database
    .ref(`locations/${locationId}`)
    .set(makeSafeForDatabase(location))

  // update pathfinding index
  if (location) {
    const pathfindingRef = database.ref(`pathfinding/${locationId}`)
    const newValue: Omit<PathingPlace, "uniqueId"> = {
      x: location.location?.x,
      z: location.location?.z,
    }
    await pathfindingRef.update(makeSafeForDatabase(newValue))
  } else {
    await database.ref(`pathfinding/${locationId}`).remove()
  }

  // update search index
  if (location) {
    const searchIndexRef = database.ref(`searchIndex/${locationId}`)
    const newValue: Omit<SearchIndexItem, "uniqueId"> = {
      d: `${location.shortName} - ${location.name}`,
      i: `${location.name} ${location.shortName} ${
        location.ownerPlayer instanceof Array
          ? location.ownerPlayer.join(" ")
          : location.ownerPlayer ?? ""
      } ${location.keywords ?? ""}`,
    }
    await searchIndexRef.update(makeSafeForDatabase(newValue))
  } else {
    await database.ref(`searchIndex/${locationId}`).remove()
  }

  console.log(
    location
      ? `Successfully saved location ${locationId}`
      : `Successfully deleted location ${locationId}`
  )
}

/**
 * save a list of every location key in the database
 * @param source
 */
export async function beforeLocationUpdate(source: string | true = true) {
  const sourceAsKey = typeof source === "string" ? source : "true"
  // get all the locations from the database where autoGenerated matches source
  return database
    .ref("locations")
    .orderByChild("autoGenerated")
    .equalTo(source)
    .once("value")
    .then(snapshot => {
      if (unusedKeys[sourceAsKey] === undefined) {
        unusedKeys[sourceAsKey] = []
      }
      snapshot.forEach(childSnapshot => {
        if (childSnapshot.key) unusedKeys[sourceAsKey].push(childSnapshot.key)
      })
    })
}

export async function afterLocationUpdate(source: string | true = true) {
  const sourceAsKey = typeof source === "string" ? source : "true"
  const keysToRemove = unusedKeys[sourceAsKey]
  if (keysToRemove === undefined) {
    return Promise.resolve()
  }

  return throttledMap(keysToRemove, key => setLocation(key, undefined))
}
