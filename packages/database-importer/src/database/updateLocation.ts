import { databaseTypeGuards, Location } from "@rapidroute/database-types"
import { PathingPlace } from "@rapidroute/database-types/dist/src/pathfinding"
import { SearchIndexItem } from "@rapidroute/database-types/dist/src/searchIndex"

import { read, write, update, remove } from "./database"
import deepCompare from "./deepCompare"
import makeSafeForDatabase, { isObject } from "./makeSafeForDatabase"
import throttledMap from "./throttledMap"
import updateAutoGen from "./updateAutoGen"

const isLocation = databaseTypeGuards.locations
const unusedKeys: Record<string, string[]> = {}

export async function setLocation(
  locationId: string,
  location: Location | undefined | null
) {
  // remove the locationId from the unusedKeys
  Object.entries(unusedKeys).forEach(([key, value]) => {
    unusedKeys[key] = value.filter(id => id !== locationId)
  })

  // Get the previous location from the database
  const previousLocation = await read(`locations/${locationId}`)

  // Validate the previous location. If it's invalid, throw an error
  if (isObject(previousLocation)) previousLocation.uniqueId = locationId
  // check for any changes
  if (deepCompare(previousLocation, location)) {
    console.log("No changes to route", locationId)
    return
  }
  if (
    previousLocation !== undefined &&
    previousLocation !== null &&
    !isLocation(previousLocation)
  ) {
    console.log(previousLocation)
    throw new Error(`Invalid location: ${locationId}`)
  }

  // if the previous route is not auto-generated, skip it
  if (previousLocation?.autoGenerated === false) {
    console.log("Skipping a non-auto-generated route", locationId)
    return
  }
  // verify the route is meant to come from this source
  if (
    previousLocation &&
    location &&
    previousLocation?.autoGenerated !== true &&
    previousLocation?.autoGenerated !== location.autoGenerated
  ) {
    console.log(
      "Source mismatch, skipping",
      locationId,
      previousLocation,
      location
    )
    return
  }

  // Save the new location to the database
  await write(`locations/${locationId}`, makeSafeForDatabase(location))
  await updateAutoGen("locations", previousLocation, location)

  // update pathfinding index
  if (location) {
    const newValue: Omit<PathingPlace, "uniqueId"> = {
      x: location.location?.x,
      z: location.location?.z,
      w: location.isSpawnWarp
    }
    await update(`pathfinding/${locationId}`, makeSafeForDatabase(newValue))
  } else {
    await remove(`pathfinding/${locationId}`)
  }

  // update search index
  if (location) {
    const newValue: Omit<SearchIndexItem, "uniqueId"> = {
      d: `${location.shortName} - ${location.name}`,
      i: `${location.name} ${location.shortName} ${
        location.ownerPlayer instanceof Array
          ? location.ownerPlayer.join(" ")
          : location.ownerPlayer ?? ""
      } ${location.keywords ?? ""}`,
    }
    await update(`searchIndex/${locationId}`, makeSafeForDatabase(newValue))
  } else {
    await remove(`searchIndex/${locationId}`)
  }

  console.log(
    location
      ? `Successfully saved location ${locationId}`
      : `Successfully deleted location ${locationId}`
  )
}

/**
 * save a list of every location key in the database
 * @param source
 */
export async function beforeLocationUpdate(source: string | true = true) {
  const sourceAsKey = typeof source === "string" ? source : "true"
  // get all the locations from the database where autoGenerated matches source
  const keys = (await read(`autoGenIndex/${sourceAsKey}`)) || []
  if (!databaseTypeGuards.autoGenIndex(keys)) {
    throw new Error("Invalid autoGenIndex")
  }
  unusedKeys[sourceAsKey] = keys.locations || []
}

export async function afterLocationUpdate(source: string | true = true) {
  const sourceAsKey = typeof source === "string" ? source : "true"
  const keysToRemove = unusedKeys[sourceAsKey]
  if (keysToRemove === undefined) {
    return Promise.resolve()
  }

  return throttledMap(keysToRemove, key => setLocation(key, undefined))
}
