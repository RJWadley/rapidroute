import {
  databaseTypeGuards,
  Pathfinding,
  Route,
} from "@rapidroute/database-types"
import {
  isWholePathfinding,
  reverseShortHandMap,
  shortHandMapKeys,
} from "@rapidroute/database-types/dist/src/pathfinding"

import { read, write, subscribe } from "./database"
import deepCompare from "./deepCompare"
import makeSafeForDatabase, { isObject } from "./makeSafeForDatabase"
import throttledMap from "./throttledMap"
import updateAutoGen from "./updateAutoGen"

const isRoute = databaseTypeGuards.routes
let pathfindingIndex: Pathfinding
subscribe(() => {
  const newValue = read("pathfinding")
  if (isWholePathfinding(newValue)) {
    pathfindingIndex = newValue
  }
})
const unusedKeys: Record<string, string[]> = {}

export async function setRoute(
  routeId: string,
  route: Route | undefined | null
) {
  // remove the routeId from the unusedKeys
  Object.entries(unusedKeys).forEach(([key, value]) => {
    unusedKeys[key] = value.filter(id => id !== routeId)
  })

  // Get the previous route from the database
  const previousRoute = await read(`routes/${routeId}`)

  // Validate the previous route. If it's invalid, throw an error
  if (isObject(previousRoute)) previousRoute.uniqueId = routeId
  // check for any changes
  if (deepCompare(previousRoute, route)) {
    console.log("No changes to route", routeId)
    return
  }

  if (
    previousRoute !== undefined &&
    previousRoute !== null &&
    !isRoute(previousRoute)
  ) {
    console.log(previousRoute)
    throw new Error(`Invalid route: ${routeId}`)
  }

  // if the previous route is not auto-generated, skip it
  if (previousRoute?.autoGenerated === false) {
    console.log("Skipping a non-auto-generated route", routeId)
    return
  }
  // verify the route is meant to come from this source
  if (
    route &&
    previousRoute &&
    previousRoute?.autoGenerated !== true &&
    previousRoute?.autoGenerated !== route.autoGenerated
  ) {
    console.log("Source mismatch, skipping", routeId)
    return
  }

  // Save the new route to the database
  await write(`routes/${routeId}`, makeSafeForDatabase(route))
  await updateAutoGen("routes", previousRoute, route)

  // Update the route information in the pathfinding index
  if (pathfindingIndex === undefined) {
    throw new Error(`Pathfinding index is undefined: ${routeId}`)
  }

  // if the route locations don't match the previous route, update the pathfinding index
  if (
    !(
      route &&
      previousRoute &&
      Object.keys(route.locations).length ===
        Object.keys(previousRoute.locations).length &&
      Object.keys(route.locations).every(
        key => route.locations[key] === previousRoute.locations[key]
      )
    )
  ) {
    console.log("Updating pathfinding index for", routeId)
    // remove this route from any locations it was previously in
    if (previousRoute) {
      // for every location in the pathfinding index
      Object.keys(previousRoute.locations).forEach(locationId => {
        const location = pathfindingIndex[locationId]
        // check every mode in that location
        shortHandMapKeys.forEach(shortHand => {
          // check every location in that mode
          const secondLocation = location[shortHand]
          if (secondLocation)
            Object.entries(secondLocation).forEach(
              ([secondLocId, routesToPlace]) => {
                // actually remove the route from the list
                const newRoutesToPlace = routesToPlace.filter(
                  r => r.n !== routeId
                )
                // update the pathfinding index
                pathfindingIndex[locationId][shortHand] = {
                  ...secondLocation,
                  [secondLocId]: newRoutesToPlace,
                }
              }
            )
        })
      })
    }

    // add this route to the locations it's in
    if (route) {
      Object.keys(route.locations).forEach(locationId => {
        const location = pathfindingIndex[locationId] || {}
        const mode = reverseShortHandMap[route.type]
        if (location?.[mode] === undefined) {
          location[mode] = {}
        }
        const routes = location?.[mode]?.[routeId] || []
        routes.push({
          n: routeId,
          g: route.numGates,
        })
        Object.keys(route.locations).forEach(toLocation => {
          if (toLocation !== locationId) {
            // add the route to the pathfinding index
            pathfindingIndex[locationId] = {
              ...location,
              [mode]: {
                ...location[mode],
                [toLocation]: routes,
              },
            }
          }
        })
      })
    }
  }

  // Save the updated pathfinding index to the database
  await write("pathfinding", makeSafeForDatabase(pathfindingIndex))

  console.log(
    route
      ? `Successfully saved route ${routeId}`
      : `Successfully deleted route ${routeId}`
  )
}

/**
 * save a list of every route key in the database, organized by source
 */
export async function beforeRouteUpdate(source: string | true = true) {
  const sourceAsKey = source === true ? "true" : source
  // get all the routes from the database where autoGenerated matches source
  const keys = (await read(`autoGenIndex/${sourceAsKey}`)) || []
  if (!databaseTypeGuards.autoGenIndex(keys)) {
    throw new Error("Invalid autoGenIndex")
  }
  unusedKeys[sourceAsKey] = keys.routes || []
}

/**
 * remove any routes that weren't updated during the update
 */
export async function afterRouteUpdate(source: string | true = true) {
  const sourceAsKey = typeof source === "string" ? source : "true"
  const keysToRemove = unusedKeys[sourceAsKey]
  if (keysToRemove === undefined) {
    return Promise.resolve()
  }

  return throttledMap(keysToRemove, key => setRoute(key, undefined))
}
