import {
  databaseTypeGuards,
  Pathfinding,
  Route,
} from "@rapidroute/database-types"
import {
  isWholePathfinding,
  reverseShortHandMap,
  shortHandMapKeys,
} from "@rapidroute/database-types/dist/src/pathfinding"

import database from "./database"
import deepCompare from "./deepCompare"
import makeSafeForDatabase, { isObject } from "./makeSafeForDatabase"
import throttledMap from "./throttledMap"

const isRoute = databaseTypeGuards.routes
let pathfindingIndex: Pathfinding
database.ref("pathfinding").on("value", snapshot => {
  const newValue: unknown = snapshot.val()
  if (isWholePathfinding(newValue)) {
    pathfindingIndex = newValue
  }
})
const unusedKeys: Record<string, string[]> = {}

/**
 * disconnects the database pathfinding listener
 */
export const disconnectRoutesListeners = () => {
  database.ref("pathfinding").off("value")
}

export async function setRoute(
  routeId: string,
  route: Route | undefined | null
) {
  // remove the routeId from the unusedKeys
  Object.entries(unusedKeys).forEach(([key, value]) => {
    unusedKeys[key] = value.filter(id => id !== routeId)
  })

  // Get the previous route from the database
  const previousRoute: unknown = (
    await database.ref(`routes/${routeId}`).get()
  ).val()

  // Validate the previous route. If it's invalid, throw an error
  if (isObject(previousRoute)) previousRoute.uniqueId = routeId
  // check for any changes
  if (deepCompare(previousRoute, route)) {
    console.log("No changes to route", routeId)
    return
  }

  if (
    previousRoute !== undefined &&
    previousRoute !== null &&
    !isRoute(previousRoute)
  ) {
    console.log(previousRoute)
    throw new Error(`Invalid route: ${routeId}`)
  }

  // if the previous route is not auto-generated, skip it
  if (previousRoute?.autoGenerated === false) {
    console.log("Skipping a non-auto-generated route", routeId)
    return
  }
  // verify the route is meant to come from this source
  if (
    route &&
    previousRoute &&
    previousRoute?.autoGenerated !== true &&
    previousRoute?.autoGenerated !== route.autoGenerated
  ) {
    console.log("Source mismatch, skipping", routeId)
    return
  }

  // Save the new route to the database
  await database.ref(`routes/${routeId}`).set(makeSafeForDatabase(route))

  // Update the route information in the pathfinding index
  if (pathfindingIndex === undefined) {
    throw new Error(`Pathfinding index is undefined: ${routeId}`)
  }

  // if the route locations don't match the previous route, update the pathfinding index
  if (
    !(
      route &&
      previousRoute &&
      Object.keys(route.locations).length ===
        Object.keys(previousRoute.locations).length &&
      Object.keys(route.locations).every(
        key => route.locations[key] === previousRoute.locations[key]
      )
    )
  ) {
    console.log("Updating pathfinding index for", routeId)
    // remove this route from any locations it was previously in
    if (previousRoute) {
      // for every location in the pathfinding index
      Object.keys(previousRoute.locations).forEach(locationId => {
        const location = pathfindingIndex[locationId]
        // check every mode
        shortHandMapKeys.forEach(shortHand => {
          // remove this route from the location's list of routes
          const thisMode = location?.[shortHand]
          if (thisMode !== undefined) {
            Object.entries(thisMode).forEach(([_, routeList]) => {
              // this bit actually does the filtering
              const index = routeList.findIndex(
                entry => entry.n === routeId && entry.g === undefined
              )
              if (index !== -1) {
                routeList.splice(index, 1)
              }
            })
            // make sure to update the pathfinding index
            pathfindingIndex[locationId][shortHand] = thisMode
          }
        })
      })
    }

    // add this route to the locations it's in
    if (route) {
      Object.keys(route.locations).forEach(locationId => {
        const location = pathfindingIndex[locationId] || {}
        const mode = reverseShortHandMap[route.type]
        if (location?.[mode] === undefined) {
          location[mode] = {}
        }
        const routes = location?.[mode]?.[routeId] || []
        routes.push({
          n: routeId,
          g: route.numGates,
        })
        // make sure to update the pathfinding index
        pathfindingIndex[locationId] = {
          ...location,
          [mode]: {
            ...location[mode],
            [routeId]: routes,
          },
        }
      })
    }
  }

  // Save the updated pathfinding index to the database
  await database.ref("pathfinding").set(makeSafeForDatabase(pathfindingIndex))
  console.log(
    route
      ? `Successfully saved route ${routeId}`
      : `Successfully deleted route ${routeId}`
  )
}

/**
 * save a list of every route key in the database, organized by source
 */
export async function beforeRouteUpdate(source: string | true = true) {
  // get all the routes from the database where autoGenerated matches source
  return database
    .ref("routes")
    .orderByChild("autoGenerated")
    .equalTo(source)
    .once("value")
    .then(snapshot => {
      const sourceAsKey = typeof source === "string" ? source : "true"
      if (unusedKeys[sourceAsKey] === undefined) {
        unusedKeys[sourceAsKey] = []
      }
      snapshot.forEach(childSnapshot => {
        if (childSnapshot.key) unusedKeys[sourceAsKey].push(childSnapshot.key)
      })
    })
}

/**
 * remove any routes that weren't updated during the update
 */
export async function afterRouteUpdate(source: string | true = true) {
  const sourceAsKey = typeof source === "string" ? source : "true"
  const keysToRemove = unusedKeys[sourceAsKey]
  if (keysToRemove === undefined) {
    return Promise.resolve()
  }

  return throttledMap(keysToRemove, key => setRoute(key, undefined))
}
