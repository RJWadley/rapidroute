import {
  Location,
  Provider,
  Route,
  RouteLocations,
  PlaceType,
} from "@rapidroute/database-types"

import getLegacyData from "./getSheetData"

// can't contain ".", "#", "$", "[", "]", or "/" or "\"
const makeSafe = (str: string) => {
  return str.replace(/[.#$/[\]]/g, "_")
}

/**
 * take the old data format and convert it to the new format
 */
export default async function getConvertedData() {
  const {
    routes,
    places,
    providers,
    aliases,
    spawnWarps,
    lightColors,
    darkColors,
    logos,
    placeLocations,
  } = await getLegacyData()

  const routesToIgnore: string[] = []
  const mappedRoutes: Route[] = routes
    .map(route => {
      const routeNumber = route.number || undefined

      // first, we need an unique id for the route that will always be the same
      const placeA = route.from > route.to ? route.to : route.from
      const placeB = route.from > route.to ? route.from : route.to
      const routeId = makeSafe(
        `${route.provider}-${routeNumber ?? placeA + placeB}`
      )

      // if we've already seen this route, ignore it the second time
      if (routesToIgnore.includes(routeId)) {
        return undefined
      }
      routesToIgnore.push(routeId)

      // and collect locations and gate info for the route
      const routesWithSameNumber = routes.filter(
        y => y.number === route.number && y.provider === route.provider
      )
      let locations: RouteLocations = {}
      const gates: Record<string, string> = {}
      routesWithSameNumber.forEach(y => {
        locations[makeSafe(y.from)] = y.fromGate ?? "none"

        const fromGate = gates[y.from] || y.fromGate
        if (fromGate) gates[y.from] = fromGate
        const toGate = gates[y.to] || y.toGate
        if (toGate) gates[y.to] = toGate
      })

      // with a fallback for MRT stations bc they're special
      if (route.mode === "MRT") {
        locations = {
          [makeSafe(route.from)]: "none",
          [makeSafe(route.to)]: "none",
        }
      }

      const mappedRoute: Route = {
        uniqueId: routeId,
        autoGenerated: true,
        name: undefined,
        description: undefined,
        locations,
        provider: makeSafe(route.provider ?? ""),
        type: route.mode,
        number: routeNumber || undefined,
        numGates: Object.keys(gates).length || undefined,
      }
      return mappedRoute
    })
    .flatMap(x => (x ? [x] : []))

  const mappedLocations: Location[] = places.map(place => {
    const locationFromMap = place.shortName
      ? placeLocations[place.shortName]
      : undefined

    let locationType: PlaceType = "Other"
    if (place.type === "MRT") locationType = "MRT Station"
    if (place.type === "airport") locationType = "Airport"
    if (place.type === "town") locationType = "City"

    const location: Location = {
      uniqueId: makeSafe(place.id),
      name:
        place.displayName ??
        place.longName ??
        place.shortName ??
        "Untitled Location",
      shortName: place.shortName ?? place.id,
      description: undefined,
      enabled: true,
      IATA: place.type === "airport" ? place.shortName || undefined : undefined,
      location:
        place.x && place.z
          ? {
              x: locationFromMap?.x ?? place.x,
              z: locationFromMap?.z ?? place.z,
              y: locationFromMap?.y ?? undefined,
            }
          : undefined,
      ownerPlayer: undefined,
      keywords: place.keywords ?? undefined,
      world: place.world,
      autoGenerated: true,
      isSpawnWarp: spawnWarps.includes(place.id),
      type: locationType,
      routes: routes
        .filter(y => y.from === place.id || y.to === place.id)
        .map(y => {
          const placeA = y.from > y.to ? y.to : y.from
          const placeB = y.from > y.to ? y.from : y.to
          const routeId = makeSafe(
            `${y.provider}-${y.number ?? placeA + placeB}`
          )
          return routeId
        })
        .filter((value, index, self) => self.indexOf(value) === index),
    }

    return location
  })

  const mappedProviders: Provider[] = providers.map(provider => {
    const newProvider: Provider = {
      uniqueId: makeSafe(provider.name),
      name: provider.displayName ?? provider.name,
      alias: aliases
        .filter(x => x.actualProvider === provider.name)
        .map(x => ({
          displayProvider: x.displayProvider,
          numberRange: {
            start: x.start,
            end: x.end,
          },
        })),
      color: {
        light: lightColors[provider.name] ?? undefined,
        dark: darkColors[provider.name] ?? undefined,
      },
      description: undefined,
      logo: logos[provider.name] ?? undefined,
      numberPrefix: provider.prefix ?? undefined,
      ownerPlayer: undefined,
      autoGenerated: true,
    }

    return newProvider
  })

  return {
    routes: mappedRoutes,
    locations: mappedLocations,
    providers: mappedProviders,
  }
}
