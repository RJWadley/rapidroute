import { Location, Locations } from "../../src/types/locations";
import { Provider, Providers } from "../../src/types/providers";
import { Route, Routes } from "../../src/types/routes";

var serviceAccount = require("./serviceAccountKey.json");
import admin from "firebase-admin";
import {
  PathfindingEdge,
  reverseShortHandMap,
} from "../../src/types/pathfinding";

export const saveDataToFirebase = async (
  routesToSave: Route[],
  locationsToSave: Location[],
  providersToSave: Provider[]
) => {
  admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    databaseURL: "https://rapidroute-7beef-default-rtdb.firebaseio.com",
  });

  const database = admin.database();

  console.log("Saving providers...");
  const providersRef = database.ref("providers");
  const providersSnapshot = await providersRef.once("value");
  const providersFromDatabase: Providers = providersSnapshot.val();
  Object.keys(providersFromDatabase).forEach((providerKey) => {
    let newValue = providersToSave.find((x) => x.uniqueId === providerKey);

    if (providersFromDatabase[providerKey].autoGenerated) {
      database.ref(`providers/${providerKey}`).set(newValue ?? null);
      database.ref(`providers/${providerKey}/uniqueId`).set(null);
    }
  });
  console.log("Providers saved.");

  console.log("Saving locations...");
  const locationsRef = database.ref("locations");
  const locationsSnapshot = await locationsRef.once("value");
  const locationsFromDatabase: Locations = locationsSnapshot.val();
  Object.keys(locationsFromDatabase).forEach((locationKey) => {
    let newValue = locationsToSave.find((x) => x.uniqueId === locationKey);

    if (locationsFromDatabase[locationKey].autoGenerated) {
      database.ref(`locations/${locationKey}`).set(newValue ?? null);
      database.ref(`locations/${locationKey}/uniqueId`).set(null);

      const searchIndex = newValue
        ? `${newValue.name} ${newValue.shortName} ${
            newValue.ownerPlayer instanceof Array
              ? newValue.ownerPlayer.join(" ")
              : newValue.ownerPlayer
          } ${newValue.type}`
        : null;
      database.ref(`searchIndex/${locationKey}`).set(searchIndex);
    }
  });
  console.log("Locations saved.");

  console.log("Saving routes...");
  const routesRef = database.ref("routes");
  const routesSnapshot = await routesRef.once("value");
  const routesFromDatabase: Routes = routesSnapshot.val();
  Object.keys(routesFromDatabase).forEach((routeKey) => {
    let newValue = routesToSave.find((x) => x.uniqueId === routeKey);

    if (routesFromDatabase[routeKey].autoGenerated) {
      database.ref(`routes/${routeKey}`).set(newValue ?? null);
      database.ref(`routes/${routeKey}/uniqueId`).set(null);

      const valueToCalcWith = newValue ?? routesFromDatabase[routeKey];
      Object.keys(valueToCalcWith.locations).forEach((locationA) => {
        Object.keys(valueToCalcWith.locations).forEach((locationB) => {
          if (locationA !== locationB) {
            const edge: Omit<PathfindingEdge, "uniqueId"> = {
              f: locationA,
              t: locationB,
              m: reverseShortHandMap[valueToCalcWith.type],
              d: getManhattanDistance(
                locationsFromDatabase[locationA],
                locationsFromDatabase[locationB]
              ),
            };

            const edgeKey = `${edge.f}-${edge.t}-${edge.m}`;

            database.ref(`pathfinding/${edgeKey}`).set(newValue ? edge : null);
          }
        });
      });
    }
  });

  console.log("Routes saved.");

  const newHash = Math.random().toString(36).substring(2, 15);
  database.ref("hashes/routes").set(newHash);
  database.ref("hashes/locations").set(newHash);
  database.ref("hashes/providers").set(newHash);
  database.ref("hashes/pathfinding").set(newHash);
  database.ref("hashes/searchIndex").set(newHash);

  console.log("Hashes updated.");

  setTimeout(() => {
    process.exit(0);
  }, 10000);
};

const getManhattanDistance = (
  locationA: Location | undefined,
  locationB: Location | undefined
): number => {
  if (locationA && locationB && locationA.location && locationB.location) {
    return (
      Math.abs(locationA.location.x - locationB.location.x) +
      Math.abs(locationA.location.z - locationB.location.z)
    );
  }
  return -1;
};
